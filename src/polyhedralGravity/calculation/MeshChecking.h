#pragma once

#include <set>
#include <memory>
#include "thrust/transform_reduce.h"
#include "thrust/execution_policy.h"
#include "polyhedralGravity/model/Polyhedron.h"
#include "polyhedralGravity/model/GravityModelData.h"
#include "polyhedralGravity/util/UtilityContainer.h"
#include "polyhedralGravity/util/UtilityConstants.h"
#include "polyhedralGravity/calculation/GravityModel.h"

namespace polyhedralGravity::MeshChecking {

    /**
     * Checks if the vertices are in such a order that the unit normals of each plane point outwards the polyhedron
     * @param polyhedron - the polyhedron consisting of vertices and triangular faces
     * @return true if all the unit normals are pointing outwards
     *
     * @note This has quadratic complexity O(n^2)! For bigger problem sizes, K-D trees/ Octrees could improve
     * the complexity to determine the intersections
     * (see https://stackoverflow.com/questions/45603469/how-to-calculate-the-normals-of-a-box)
     */
    bool checkNormalsOutwardPointing(const Polyhedron &polyhedron);

    /**
     * Checks if no triangle is degenerated by checking the surface area being greater than zero.
     * E.g. two points are the same or all three are collinear.
     * @param polyhedron - the polyhedron consisting of vertices and triangular faces
     * @return true if triangles are fine and one of them is degenerated
     */
    bool checkTrianglesNotDegenerated(const Polyhedron &polyhedron);


    namespace detail {

        /**
         * Calculates how often a vector starting at a specific origin intersects a polyhedron's mesh's triangles.
         * @param rayOrigin - the origin of the ray
         * @param rayVector - the vector describing the ray
         * @param polyhedron - the polyhedron consisting of vertices and triangular faces
         * @return true if the ray intersects the triangle
         */
        size_t
        countRayPolyhedronIntersections(const Array3 &rayOrigin, const Array3 &rayVector, const Polyhedron &polyhedron);

        /**
         * Calculates how often a vector starting at a specific origin intersects a triangular face.
         * Uses the Möller–Trumbore intersection algorithm.
         * @param rayOrigin - the origin of the ray
         * @param rayVector - the vector describing the ray
         * @param triangle - a triangular face
         * @return intersection point or null
         *
         * @related Adapted from https://en.wikipedia.org/wiki/Möller–Trumbore_intersection_algorithm
         */
        std::unique_ptr<Array3>
        rayIntersectsTriangle(const Array3 &rayOrigin, const Array3 &rayVector, const Array3Triplet &triangle);

    }

}
